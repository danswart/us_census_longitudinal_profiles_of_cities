---
title: "Government Employee Earnings Analysis (PUMS Microdata)"
subtitle: "By Level of Government: Local, State, Federal"
authors: 
  - name: "Dan Swart, CPA (ret)"
  - name: "Claude Sonnet 4.5"
date: today
date-format: long
format:
  html:
    resources:
      - reference-backlinks.js
    include-after-body:    
      - text: |
          # <script type="text/javascript" src="reference-backlinks.js"></script>
    default: true         
    code-copy: true
    code-link: true
    code-fold: true
    code-summary: "Show the code"
    code-overflow: wrap
    code-block-bg: "#FAEBD7"
    code-block-border-left: "#31BAE9"
    embed-resources: false
    include-in-header:
      - text: 
          <link href="https://fonts.googleapis.com/css2?family=Lato&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Montserrat&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Cabin&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Schoolbell&display=swap" rel="stylesheet">
      - header.html
    css:
      - swart.css
      - tachyons.min.css
      - r-colors.css
    fontsize: 18pt
    lightbox: true
    page-layout: full
    fig-width: 13
    fig-height: 8
    fig-dpi: 300
    html-math-method: katex
    df-print: paged
    toc: true
    toc-float: true
    citeproc: true
    link-citations: true
    linestretch: 1.0
    
  typst:
    fig-height: 8
    fig-dpi: 300
    margin:
      x: 1in
      y: 1in
    toc: true
    fontsize: 16pt
    mainfont: "Cabin"
    
  revealjs:
    slide-number: true
    transition: fade
    code-overflow: wrap
    center: true
    smaller: true
    scrollable: true
    chalkboard: true
    multiplex: false
    theme: solarized
    reference-location: margin
    logo: img/red-cross-640-435.png
    footer: "Footer text"
    code-block-height: 650px

editor: source

quarto:
  render:
    cache-refresh: true

execute:
  echo: true
  message: false
  warning: false
  eval: true
  fig-width: 13
  fig-height: 8

knitr:
  opts_chunk:
    echo: true
    error: false
    warning: false
    message: false
    cache: false
---


```{r}
#| label: params
#| include: false

# =============================================================================
# PARAMETERS - CHANGE THESE FOR A DIFFERENT CITY/YEARS
# =============================================================================

params <- base::list(
  city       = "Schertz",
  state      = "TX",
  # NOTE: 2020 excluded - no 1-year ACS due to COVID response rates
  # NOTE: 2022 excluded - PUMA boundary inconsistencies in tidycensus
  years      = c(2019, 2021, 2023, 2024),
  min_age    = 20L,
  survey     = "acs1",
  base_year  = 2024,
  cache_dir  = "cache/pums_gov_acs1_v2"
)

# =============================================================================
```

```{r}
#| label: setup
#| include: false

# =============================================================================
# PACKAGE VERIFICATION
# =============================================================================

required_pkgs <- c(
  "tidycensus", "tigris", "dplyr", "purrr", "tibble", "stringr", "tidyr",
  "digest", "lubridate", "quantmod", "zoo", "ggplot2", "flextable",
  "srvyr", "survey", "readr", "writexl", "sf", "mapview", "httr"
)

missing <- required_pkgs[
  !base::vapply(required_pkgs, requireNamespace, logical(1L), quietly = TRUE)
]

if (base::length(missing) > 0L) {
  base::stop("Install missing packages:\n", base::paste(missing, collapse = ", "))
}

# =============================================================================
# LOAD REQUIRED LIBRARIES
# =============================================================================

base::suppressPackageStartupMessages({
  library(tidycensus)
  library(tigris)
})

# =============================================================================
# SOURCE UTILITY FILES
# =============================================================================

source("R/skew_check.R")
source("R/quick_distrib.R")
source("R/distrib_ridge.R")
source("R/distrib_quantile_evolution.R")
source("R/distrib_acceleration.R")

# =============================================================================
# OPTIONS
# =============================================================================

base::options(
  tigris_use_cache = TRUE,
  tidycensus.show_progress = FALSE,
  survey.lonely.psu = "adjust",
  scipen = 999
)

options(scipen = 999)
options(qic.clshade = T)
options(qic.linecol = 'black')
options(qic.signalcol = "firebrick")
options(qic.targetcol = "purple")
options(DT.options = list(dom = 'pBlfrti'))
options(shiny.maxRequestSize = 50 * 1024^2)
options(tigris_use_cache = TRUE)
options(device = "RStudioGD") 

httr::set_config(httr::config(noprogress = TRUE))
mapview::mapviewOptions(verbose = FALSE)
mapview::mapviewOptions(basemaps = "OpenStreetMap")

# Force dplyr precedence
select <- dplyr::select
filter <- dplyr::filter

# =============================================================================
# YEAR COLORS FOR PLOTS
# =============================================================================

year_colors <- c(
  "2019" = "#1b9e77",
  "2021" = "#d95f02", 
  "2023" = "#7570b3",
  "2024" = "#e7298a"
)

# =============================================================================
# GGPLOT2 THEME
# =============================================================================

ggplot2::theme_set(
  ggplot2::theme_minimal(base_size = 20) +
    ggplot2::theme(
      plot.title.position = "plot",
      plot.title = ggtext::element_textbox_simple(
        family = "Cabin",
        face = "bold",
        color = "darkgreen",
        size = 16,
        fill = "yellow",
        lineheight = 0.9,
        padding = ggplot2::margin(5.5, 5.5, 0.0, 5.5),
        margin = ggplot2::margin(0, 0, 5.5, 0)
      ),
      plot.subtitle = ggtext::element_textbox_simple(
        family = "Cabin",
        color = "darkgreen",
        face = "bold",
        size = 14,
        fill = "yellow",
        lineheight = 0.9,
        padding = ggplot2::margin(5.5, 5.5, 5.5, 5.5),
        margin = ggplot2::margin(0.0, 0, 5.5, 0)
      ),
      plot.caption = ggtext::element_markdown(
        family = "Cabin",
        size = 14,
        hjust = 1,
        color = "darkblue",
        face = "italic",
        fill = "yellow",
        lineheight = 1.0
      ),
      axis.text.x = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 12,
        angle = 45,
        hjust = 1
      ),
      axis.title.x = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 14),
      axis.text.y = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 12,
        angle = 45,
        hjust = 1
      ),
      axis.title.y = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 12),
      strip.text = ggtext::element_markdown(
        family = "Cabin",
        color = "black",
        size = 12,
        face = "italic",
        margin = ggplot2::margin(2, 0, 0.5, 0, "lines")
      ),
      axis.text = ggtext::element_markdown(
        family = "Cabin",
        color = "black"),
      panel.background = ggplot2::element_rect(fill = "white", color = NA),
      plot.background = ggplot2::element_rect(fill = "white", color = NA),
      legend.position = "none",
      panel.spacing.x = grid::unit(1.5, "cm"),
      panel.spacing.y = grid::unit(1.5, "cm"),
      plot.margin = ggplot2::margin(20, 20, 20, 20, "pt")
    )
)

# =============================================================================
# FLEXTABLE DEFAULTS
# =============================================================================

flextable::set_flextable_defaults(
  font.size = 14, 
  font.family = "Cabin",
  font.color = "black",
  table.layout = "fixed",
  border.color = "darkgray",
  padding.top = 3, padding.bottom = 3,
  padding.left = 4, padding.right = 4,
  line_spacing = 1.3,
  digits = 2,
  decimal.mark = ".",
  big.mark = " ",
  na_str = "<na>",
  post_process_html = identity,
  post_process_docx = identity
)

base::set.seed(123)
```

```{r}
#| label: helper-functions
#| include: false

# =============================================================================
# CACHING UTILITIES
# =============================================================================

ds_cache_path <- function(cache_dir, key, ext = "rds") {
  base::dir.create(cache_dir, showWarnings = FALSE, recursive = TRUE)
  base::file.path(cache_dir, base::paste0(key, ".", ext))
}

ds_cache_key <- function(prefix, params) {
  digest::digest(base::list(prefix = prefix, params = params), algo = "xxhash64")
}

ds_cache_read <- function(path) {
  if (base::file.exists(path)) base::readRDS(path) else NULL
}

ds_cache_write <- function(x, path) {
  base::dir.create(base::dirname(path), showWarnings = FALSE, recursive = TRUE)
  base::saveRDS(x, path)
  base::invisible(x)
}

# =============================================================================
# FIND PUMAS CONTAINING A CITY
# =============================================================================

ds_get_city_pumas <- function(city, state, year = 2020, cache_dir) {
  key <- ds_cache_key("city_pumas", base::list(city = city, state = state, year = year))
  path <- ds_cache_path(cache_dir, key)
  cached <- ds_cache_read(path)
  if (!base::is.null(cached)) return(cached)
  
  pumas <- base::suppressMessages(
    tigris::pumas(state = state, year = year, progress_bar = FALSE)
  )
  
  places <- base::suppressMessages(
    tigris::places(state = state, year = year, progress_bar = FALSE)
  )
  
  city_pattern <- base::paste0("^", city, " city")
  city_sf <- places[base::grepl(city_pattern, places$NAME, ignore.case = TRUE), ]
  
  if (base::nrow(city_sf) == 0L) {
    city_sf <- places[base::grepl(
      base::paste0("^", city, "$"),
      places$NAME,
      ignore.case = TRUE
    ), ]
  }
  
  if (base::nrow(city_sf) == 0L) {
    base::stop("City '", city, "' not found in ", state)
  }
  
  city_sf <- sf::st_transform(city_sf, sf::st_crs(pumas))
  intersecting <- base::suppressMessages(
    sf::st_intersects(pumas, city_sf, sparse = FALSE)
  )
  city_pumas <- pumas[base::apply(intersecting, 1, base::any), ]
  
  puma_col <- base::grep("^PUMACE", base::names(city_pumas), value = TRUE)[1L]
  puma_codes <- city_pumas[[puma_col]]
  
  result <- base::list(
    puma_codes = puma_codes,
    puma_names = city_pumas$NAMELSAD20,
    city_name = city_sf$NAME[1L],
    n_pumas = base::length(puma_codes)
  )
  
  ds_cache_write(result, path)
}

# =============================================================================
# PUMS DATA RETRIEVAL - HANDLES BOTH LABELED AND UNLABELED COW DATA
# =============================================================================

ds_get_pums_gov_earnings <- function(city, state, puma_codes, year, min_age = 20L,
                                     survey = "acs1", cache_dir) {
  
  # NO CACHING - always fetch fresh to avoid stale data issues
  pums_vars <- c("AGEP", "WAGP", "SEMP", "COW", "PUMA")
  age_filter <- base::list(AGEP = min_age:99L)
  
  # Suppress output during API call
  tmp_file <- base::tempfile()
  tmp_err <- base::tempfile()
  
  base::sink(tmp_file, type = "output")
  base::sink(tmp_err, type = "message")
  
  raw <- base::tryCatch({
    result <- tidycensus::get_pums(
      variables        = pums_vars,
      state            = state,
      year             = year,
      survey           = survey,
      variables_filter = age_filter,
      rep_weights      = "person",
      recode           = TRUE,
      show_call        = FALSE
    )
    base::sink(type = "message")
    base::sink(type = "output")
    base::unlink(c(tmp_file, tmp_err))
    result
  }, error = function(e) {
    base::sink(type = "message")
    base::sink(type = "output")
    base::unlink(c(tmp_file, tmp_err))
    base::stop(e)
  })
  
  if (base::is.null(raw) || base::nrow(raw) == 0L) {
    base::warning("get_pums returned no data for year ", year)
    return(NULL)
  }
  
  # Filter to target PUMAs
  raw <- raw[raw$PUMA %in% puma_codes, ]
  
  if (base::nrow(raw) == 0L) {
    base::warning("No PUMS records found for ", city, " PUMAs in year ", year)
    return(NULL)
  }
  
  # Calculate earnings
  raw$earnings <- base::as.numeric(raw$WAGP) + base::as.numeric(raw$SEMP)
  raw$earnings <- base::ifelse(raw$earnings < 0, 0, raw$earnings)
  
  # =========================================================================
  # ROBUST COW HANDLING - works with or without COW_label
  # =========================================================================
  
  has_cow_label <- "COW_label" %in% base::names(raw) && 
                   !base::all(base::is.na(raw$COW_label))
  
  if (has_cow_label) {
    # Use labels when available (typically ACS 5-year or older 1-year data)
    raw$gov_level <- dplyr::case_when(
      base::grepl("Local government", raw$COW_label, ignore.case = TRUE) ~ "Local Government",
      base::grepl("State government", raw$COW_label, ignore.case = TRUE) ~ "State Government",
      base::grepl("Federal government", raw$COW_label, ignore.case = TRUE) ~ "Federal Government",
      TRUE ~ NA_character_
    )
    base::message("Year ", year, ": Using COW_label for government classification")
  } else {
    # Use numeric codes (2024+ ACS 1-year data - recode not yet supported)
    # COW codes: 3 = Local govt, 4 = State govt, 5 = Federal govt
    cow_num <- base::suppressWarnings(base::as.integer(raw$COW))
    raw$gov_level <- dplyr::case_when(
      cow_num == 3L ~ "Local Government",
      cow_num == 4L ~ "State Government",
      cow_num == 5L ~ "Federal Government",
      TRUE ~ NA_character_
    )
    base::message("Year ", year, ": Using numeric COW codes for government classification")
    base::message("  COW values found: ", paste(sort(unique(raw$COW)), collapse = ", "))
  }
  
  # Add year column

  raw$year <- year
  
  # Convert factors to character
  factor_cols <- base::names(raw)[base::vapply(raw, base::is.factor, logical(1L))]
  for (col in factor_cols) {
    raw[[col]] <- base::as.character(raw[[col]])
  }
  
  # Report what we found
  gov_counts <- base::table(raw$gov_level, useNA = "ifany")
  base::message("  Government employees found: ", 
                paste(names(gov_counts), gov_counts, sep = "=", collapse = ", "))
  

  return(raw)
}

# =============================================================================
# CPI / INFLATION
# =============================================================================

ds_get_cpi_annual <- function(start_year, end_year, base_year, cache_dir) {
  key <- ds_cache_key("cpi_annual", base::list(
    start_year = start_year, end_year = end_year, base_year = base_year
  ))
  path <- ds_cache_path(cache_dir, key)
  cached <- ds_cache_read(path)
  if (!base::is.null(cached)) return(cached)
  
  xt <- base::suppressMessages(base::suppressWarnings(
    quantmod::getSymbols("CPIAUCSL", src = "FRED", auto.assign = FALSE)
  ))
  
  df <- tibble::tibble(
    date = base::as.Date(zoo::index(xt)),
    cpi  = base::as.numeric(xt[, 1L])
  )
  df$year <- lubridate::year(df$date)
  df <- df[df$year >= start_year & df$year <= end_year, ]
  
  annual <- dplyr::summarise(
    dplyr::group_by(df, year),
    cpi_annual_avg = base::mean(cpi, na.rm = TRUE),
    .groups = "drop"
  )
  
  base_cpi <- annual$cpi_annual_avg[annual$year == base_year]
  if (base::length(base_cpi) != 1L) {
    base::stop("Base year CPI not found for year ", base_year)
  }
  
  annual$base_year <- base_year
  annual$factor_to_base <- base_cpi / annual$cpi_annual_avg
  
  ds_cache_write(annual, path)
}

# =============================================================================
# FLEXTABLE STYLING
# =============================================================================

ds_style_flextable <- function(ft, title = NULL) {
  if (!base::is.null(title)) {
    ft <- flextable::add_header_lines(ft, values = title)
    ft <- flextable::color(ft, i = 1, part = "header", color = "blue")
    ft <- flextable::italic(ft, i = 1, part = "header")
    ft <- flextable::align(ft, i = 1, part = "header", align = "left")
    ft <- flextable::fontsize(ft, i = 1, part = "header", size = 12)
    ft <- flextable::bg(ft, i = 1, part = "header", bg = "white")
    ft <- flextable::bg(ft, i = 2, part = "header", bg = "palegreen")
  } else {
    ft <- flextable::bg(ft, i = 1, part = "header", bg = "palegreen")
  }
  ft <- flextable::autofit(ft)
  ft
}
```


# Object Naming Convention Reference

This document uses a consistent naming convention for all global objects:

- **`raw_*`** — Data as loaded from external sources (Census API, FRED, tigris)
- **`derived_*`** — Filtered, transformed, or calculated from raw data
- **`display_*`** — Formatted specifically for tables/output (not for analysis)

```{r}
#| label: object-reference-table

object_ref <- tibble::tibble(
  Object = c(
    "raw_pums_list",
    "raw_pums_all",
    "raw_cpi",
    "raw_city_puma_info",
    "raw_puma_codes",
    "raw_pumas_sf",
    "raw_city_sf",
    "derived_inflation_rate",
    "derived_gov_employees",
    "derived_gov_results",
    "derived_overall_results",
    "display_*"
  ),
  
  `Check Skew?` = c(
    "YES - by year",
    "NO",
    "N/A",
    "N/A",
    "N/A",
    "N/A",
    "N/A",
    "N/A",
    "YES - by year & gov_level",
    "NO",
    "NO",
    "NO"
  ),
  
  Why = c(
    "List of raw person-level data by year - check each year separately",
    "Years stacked together - distribution conflates time periods",
    "Reference table for inflation adjustment",
    "Metadata about PUMAs (codes, names)",
    "Vector of PUMA codes only",
    "Spatial boundaries only",
    "Spatial boundaries only",
    "Percentages derived from CPI",
    "Filtered to gov employees - still person-level, check by strata",
    "Already aggregated to weighted means/medians",
    "Already aggregated to weighted means/medians",
    "Formatted for display, not analysis"
  )
)

ft_ref <- flextable::flextable(object_ref)
ft_ref <- ds_style_flextable(ft_ref, title = "Object Naming Convention & Skew Check Reference")

ft_ref <- flextable::color(
  ft_ref,
  i = ~ stringr::str_detect(`Check Skew?`, "^YES"),
  j = "Check Skew?",
  color = "darkgreen"
)
ft_ref <- flextable::bold(
  ft_ref,
  i = ~ stringr::str_detect(`Check Skew?`, "^YES"),
  j = "Check Skew?"
)
ft_ref <- flextable::color(
  ft_ref,
  i = ~ `Check Skew?` == "NO",
  j = "Check Skew?",
  color = "red"
)
ft_ref <- flextable::width(ft_ref, j = "Why", width = 4)
ft_ref
```


# Overview

This document analyzes earnings for **government employees** (adults `r params$min_age`+) in the **`r params$city`, `r params$state` area** using PUMS microdata, broken down by level of government (Local, State, Federal).

**Data source:** ACS `r params$survey` PUMS data for years `r paste(params$years, collapse = ", ")`.

**Important notes:**

- **2020 excluded:** The regular 1-year ACS was not released due to COVID-related low response rates
- **2022 excluded:** PUMA boundary inconsistencies in tidycensus
- **1-year vs 5-year:** This analysis uses 1-year estimates which have larger standard errors but provide more recent data


# PUMA Identification

```{r}
#| label: find-pumas

# -----------------------------------------------------------------------------
# RAW: City PUMA information
# -----------------------------------------------------------------------------
raw_city_puma_info <- ds_get_city_pumas(
  city      = params$city,
  state     = params$state,
  year      = 2020,
  cache_dir = params$cache_dir
)

raw_puma_codes <- raw_city_puma_info$puma_codes
```

**`r params$city`** is located in **`r raw_city_puma_info$n_pumas`** PUMA(s):

```{r}
#| label: puma-table

display_puma <- tibble::tibble(
  `PUMA Code` = raw_city_puma_info$puma_codes,
  `PUMA Name` = raw_city_puma_info$puma_names
)

ft_puma <- flextable::flextable(display_puma)
ft_puma <- ds_style_flextable(
  ft_puma,
  title = base::paste0("PUMAs Containing ", params$city, ", ", params$state)
)
ft_puma
```

```{r}
#| label: spatial-data
#| include: false

# -----------------------------------------------------------------------------
# RAW: Spatial data for mapping
# -----------------------------------------------------------------------------
raw_pumas_sf <- base::suppressMessages(
  tigris::pumas(state = params$state, year = 2020, progress_bar = FALSE)
)

raw_places_sf <- base::suppressMessages(
  tigris::places(state = params$state, year = 2020, progress_bar = FALSE)
)

# Find the city boundary
city_pattern <- base::paste0("^", params$city, " city")
raw_city_sf <- raw_places_sf[base::grepl(city_pattern, raw_places_sf$NAME, ignore.case = TRUE), ]
if (base::nrow(raw_city_sf) == 0L) {
  raw_city_sf <- raw_places_sf[base::grepl(
    base::paste0("^", params$city, "$"), raw_places_sf$NAME, ignore.case = TRUE
  ), ]
}

# Get the PUMAs containing the city
puma_col <- base::grep("^PUMACE", base::names(raw_pumas_sf), value = TRUE)[1L]
raw_city_pumas_sf <- raw_pumas_sf[raw_pumas_sf[[puma_col]] %in% raw_puma_codes, ]

# Find major cities within the PUMAs
raw_places_in_pumas <- base::suppressMessages(
  raw_places_sf[sf::st_intersects(raw_places_sf, raw_city_pumas_sf, sparse = FALSE)[, 1], ]
)
raw_places_in_pumas <- raw_places_in_pumas[
  base::grepl("city|town", raw_places_in_pumas$NAMELSAD, ignore.case = TRUE),
]

raw_places_to_label <- NULL
if (base::nrow(raw_places_in_pumas) > 0L) {
  raw_places_in_pumas <- raw_places_in_pumas[base::order(-raw_places_in_pumas$ALAND), ]
  raw_places_in_pumas <- raw_places_in_pumas[
    !base::grepl(base::paste0("^", params$city), raw_places_in_pumas$NAME, ignore.case = TRUE),
  ]
  if (base::nrow(raw_places_in_pumas) > 0L) {
    raw_places_to_label <- utils::head(raw_places_in_pumas, 6)
  }
}
```

```{r}
#| label: puma-map
#| fig-height: 6

# Create interactive map
raw_city_pumas_sf$puma_label <- base::paste0("PUMA ", raw_city_pumas_sf[[puma_col]])
raw_city_sf$label <- params$city

m <- mapview::mapview(
  raw_city_pumas_sf,
  col.regions = "lightblue",
  color = "steelblue",
  alpha.regions = 0.3,
  layer.name = "PUMA Coverage",
  label = raw_city_pumas_sf$puma_label
)

m <- m + mapview::mapview(
  raw_city_sf,
  col.regions = "tomato",
  color = "darkred",
  alpha.regions = 0.5,
  layer.name = base::paste0(params$city, " (Target)"),
  label = raw_city_sf$label
)

if (!base::is.null(raw_places_to_label) && base::nrow(raw_places_to_label) > 0L) {
  raw_places_to_label$label <- raw_places_to_label$NAME
  m <- m + mapview::mapview(
    raw_places_to_label,
    col.regions = "gray70",
    color = "gray50",
    alpha.regions = 0.2,
    layer.name = "Other Cities in PUMA",
    label = raw_places_to_label$label
  )
}

m
```


# Data Retrieval

```{r}
#| label: pull-pums

# -----------------------------------------------------------------------------
# RAW: PUMS data by year (list of data frames)
# -----------------------------------------------------------------------------
message("Fetching PUMS data for years: ", paste(params$years, collapse = ", "))

raw_pums_list <- purrr::map(params$years, function(y) {
  message("\n--- Processing year ", y, " ---")
  tryCatch({
    ds_get_pums_gov_earnings(
      city       = params$city,
      state      = params$state,
      puma_codes = raw_puma_codes,
      year       = y,
      min_age    = params$min_age,
      survey     = params$survey,
      cache_dir  = params$cache_dir
    )
  }, error = function(e) {
    base::warning("Failed to get PUMS for year ", y, ": ", e$message)
    NULL
  })
})

# Name the list elements by year for easy access
names(raw_pums_list) <- params$years

# Remove failed years
raw_pums_list <- raw_pums_list[!base::vapply(raw_pums_list, base::is.null, logical(1L))]

# -----------------------------------------------------------------------------
# RAW: Combined PUMS (stacked years - use with caution)
# -----------------------------------------------------------------------------
raw_pums_all <- dplyr::bind_rows(raw_pums_list)

# Verify gov_level exists
if (!"gov_level" %in% names(raw_pums_all)) {
  stop("CRITICAL: gov_level column not found in raw_pums_all. Check ds_get_pums_gov_earnings function.")
}

# -----------------------------------------------------------------------------
# DERIVED: Government employees only (filtered from raw)
# -----------------------------------------------------------------------------
derived_gov_employees <- raw_pums_all |>
  dplyr::filter(!is.na(gov_level), earnings > 0)

message("\n=== Data Summary ===")
message("Total records (all workers): ", nrow(raw_pums_all))
message("Government employees with earnings > 0: ", nrow(derived_gov_employees))
```

```{r}
#| label: data-diagnostics

# Show what years we got and sample sizes
cat("Years retrieved:", paste(names(raw_pums_list), collapse = ", "), "\n")
cat("Total records (all workers):", nrow(raw_pums_all), "\n")
cat("Government employees with earnings > 0:", nrow(derived_gov_employees), "\n\n")

# Check gov_level distribution
cat("Government level distribution by year:\n")
print(table(derived_gov_employees$gov_level, derived_gov_employees$year, useNA = "ifany"))
```

```{r}
#| label: cpi-data

# -----------------------------------------------------------------------------
# RAW: CPI data for inflation adjustment
# -----------------------------------------------------------------------------
raw_cpi <- ds_get_cpi_annual(
  start_year = base::min(params$years),
  end_year   = base::max(params$years),
  base_year  = params$base_year,
  cache_dir  = params$cache_dir
)

# -----------------------------------------------------------------------------
# DERIVED: Inflation rate by year
# -----------------------------------------------------------------------------
derived_inflation_rate <- raw_cpi |>
  dplyr::arrange(year) |>
  dplyr::mutate(
    cpi_prior = dplyr::lag(cpi_annual_avg),
    inflation_pct = (cpi_annual_avg - cpi_prior) / cpi_prior * 100
  ) |>
  dplyr::filter(!is.na(inflation_pct)) |>
  dplyr::select(year, cpi_annual_avg, inflation_pct)
```


# Distribution Evolution Analysis

This section examines how earnings distributions shift over time—not just the averages, but the entire shape and spread.

```{r}
#| label: load-distrib-functions
#| include: false

# Source distribution evolution functions (already sourced in setup, but be safe)
if (!exists("distrib_ridge")) source("R/distrib_ridge.R")
if (!exists("distrib_quantile_evolution")) source("R/distrib_quantile_evolution.R")
if (!exists("distrib_acceleration")) source("R/distrib_acceleration.R")

# Ensure ggridges is available
if (!requireNamespace("ggridges", quietly = TRUE)) {
  stop("Install ggridges: install.packages('ggridges')")
}
```


## Ridge Plots: Watching the Distribution Walk

Ridge plots stack each year's density curve vertically, letting you see the entire distribution shift over time. The vertical line within each ridge marks the median.

```{r}
#| label: ridge-all-gov
#| fig-width: 11
#| fig-height: 7

# All government employees combined
distrib_ridge(
  data = derived_gov_employees,
  value_col = "earnings",
  year_col = "year",
  title = "All Government Employees: Earnings Distribution Shift"
)
```

```{r}
#| label: ridge-by-gov-level
#| fig-width: 11
#| fig-height: 12

# Faceted by government level
distrib_ridge(
  data = derived_gov_employees,
  value_col = "earnings",
  year_col = "year",
  group_col = "gov_level",
  title = "Earnings Distribution Shift by Government Level"
)
```

**What to look for:**

- **Rightward march**: Distribution shifting toward higher earnings
- **Shape changes**: Getting wider (more variance) or narrower (compression)
- **Tail behavior**: Right tail stretching (high earners pulling away) or compressing


## Quantile Evolution: Who's Moving and How Fast?

This plot tracks the 10th, 25th, 50th (median), 75th, and 90th percentiles over time. It reveals whether the whole distribution moves together or if certain segments are outpacing others.

```{r}
#| label: quantile-all-gov
#| fig-width: 10
#| fig-height: 6

# All government employees
distrib_quantile_evolution(
  data = derived_gov_employees,
  value_col = "earnings",
  year_col = "year",
  title = "All Government: Percentile Evolution"
)
```

```{r}
#| label: quantile-by-gov-level
#| fig-width: 12
#| fig-height: 8

# By government level
distrib_quantile_evolution(
  data = derived_gov_employees,
  value_col = "earnings",
  year_col = "year",
  group_col = "gov_level",
  title = "Percentile Evolution by Government Level"
)
```

**Interpretation guide:**

| Pattern | Meaning |
|---------|---------|
| Parallel lines | Uniform shift—everyone moves together |
| Diverging lines (fan out) | Inequality growth—top pulling away from bottom |
| Converging lines | Compression—distribution tightening |
| P90 rising faster than P50 | Top earners gaining disproportionately |
| P10 flat while others rise | Bottom earners being left behind |


## Acceleration Analysis: Rate of Change and Its Change

This table quantifies what the plots show visually: year-over-year percent changes, acceleration (is growth speeding up or slowing down?), and inequality measures.

```{r}
#| label: acceleration-all-gov

# All government combined
accel_all <- distrib_acceleration(
  data = derived_gov_employees,
  value_col = "earnings",
  year_col = "year",
  title = "All Government Employees: Earnings Change & Acceleration"
)

accel_all$table
```

```{r}
#| label: acceleration-by-gov-level

# By government level
accel_by_level <- distrib_acceleration(
  data = derived_gov_employees,
  value_col = "earnings",
  year_col = "year",
  group_col = "gov_level",
  title = "Earnings Change & Acceleration by Government Level"
)

accel_by_level$table
```

**Column definitions:**

| Column | What it measures |
|--------|------------------|
| **Mean Δ%** | Year-over-year percent change in mean earnings |
| **Accel** | Change in the percent change (in percentage points). Positive = growth accelerating, negative = decelerating |
| **90/10** | Ratio of 90th percentile to 10th percentile. Higher = more inequality |
| **90/10 Δ** | Change in the 90/10 ratio. Positive = inequality growing |


## Year-over-Year Comparison: Individual Distributions

For detailed inspection, here are the weighted distributions for each year overlaid on a single plot per government level.

```{r}
#| label: overlay-local
#| fig-width: 10
#| fig-height: 6

# Local Government - all years overlaid (weighted)
local_all_years <- derived_gov_employees |>
  dplyr::filter(gov_level == "Local Government")

if (nrow(local_all_years) > 0) {
  ggplot2::ggplot(local_all_years, ggplot2::aes(x = earnings, fill = factor(year), color = factor(year), weight = PWGTP)) +
    ggplot2::geom_density(alpha = 0.3, linewidth = 1) +
    ggplot2::scale_fill_manual(values = year_colors, name = "Year") +
    ggplot2::scale_color_manual(values = year_colors, name = "Year") +
    ggplot2::scale_x_continuous(
      labels = function(x) paste0("$", format(x / 1000, big.mark = ","), "K"),
      limits = c(0, quantile(local_all_years$earnings, 0.98))
    ) +
    ggplot2::labs(
      title = "Local Government: Earnings Distribution by Year (Weighted)",
      subtitle = "Overlaid densities show year-over-year shift",
      x = "Earnings",
      y = "Density"
    ) +
    ggplot2::theme_minimal(base_size = 14) +
    ggplot2::theme(
      plot.title = ggplot2::element_text(face = "bold"),
      legend.position = "right"
    )
} else {
  message("No Local Government data available")
}
```

```{r}
#| label: overlay-state
#| fig-width: 10
#| fig-height: 6

# State Government - all years overlaid (weighted)
state_all_years <- derived_gov_employees |>
  dplyr::filter(gov_level == "State Government")

if (nrow(state_all_years) > 0) {
  ggplot2::ggplot(state_all_years, ggplot2::aes(x = earnings, fill = factor(year), color = factor(year), weight = PWGTP)) +
    ggplot2::geom_density(alpha = 0.3, linewidth = 1) +
    ggplot2::scale_fill_manual(values = year_colors, name = "Year") +
    ggplot2::scale_color_manual(values = year_colors, name = "Year") +
    ggplot2::scale_x_continuous(
      labels = function(x) paste0("$", format(x / 1000, big.mark = ","), "K"),
      limits = c(0, quantile(state_all_years$earnings, 0.98))
    ) +
    ggplot2::labs(
      title = "State Government: Earnings Distribution by Year (Weighted)",
      subtitle = "Overlaid densities show year-over-year shift",
      x = "Earnings",
      y = "Density"
    ) +
    ggplot2::theme_minimal(base_size = 14) +
    ggplot2::theme(
      plot.title = ggplot2::element_text(face = "bold"),
      legend.position = "right"
    )
} else {
  message("No State Government data available")
}
```

```{r}
#| label: overlay-federal
#| fig-width: 10
#| fig-height: 6

# Federal Government - all years overlaid (weighted)
federal_all_years <- derived_gov_employees |>
  dplyr::filter(gov_level == "Federal Government")

if (nrow(federal_all_years) > 0) {
  ggplot2::ggplot(federal_all_years, ggplot2::aes(x = earnings, fill = factor(year), color = factor(year), weight = PWGTP)) +
    ggplot2::geom_density(alpha = 0.3, linewidth = 1) +
    ggplot2::scale_fill_manual(values = year_colors, name = "Year") +
    ggplot2::scale_color_manual(values = year_colors, name = "Year") +
    ggplot2::scale_x_continuous(
      labels = function(x) paste0("$", format(x / 1000, big.mark = ","), "K"),
      limits = c(0, quantile(federal_all_years$earnings, 0.98))
    ) +
    ggplot2::labs(
      title = "Federal Government: Earnings Distribution by Year (Weighted)",
      subtitle = "Overlaid densities show year-over-year shift",
      x = "Earnings",
      y = "Density"
    ) +
    ggplot2::theme_minimal(base_size = 14) +
    ggplot2::theme(
      plot.title = ggplot2::element_text(face = "bold"),
      legend.position = "right"
    )
} else {
  message("No Federal Government data available")
}
```


## Summary: What the Distributions Tell Us

```{r}
#| label: distribution-summary
#| results: asis

# Extract key metrics for narrative
accel_data <- accel_by_level$data

# Get latest year stats
latest <- accel_data |>
  dplyr::filter(year == max(year)) |>
  dplyr::select(group, mean_pct_chg, mean_accel, p90_p10_ratio)

# Build narrative
cat("**Key findings from distribution analysis:**\n\n")

for (i in seq_len(nrow(latest))) {
  grp <- latest$group[i]
  chg <- latest$mean_pct_chg[i]
  acc <- latest$mean_accel[i]
  ratio <- latest$p90_p10_ratio[i]
  
  direction <- ifelse(chg > 0, "increased", "decreased")
  accel_word <- ifelse(!is.na(acc) && acc > 0, "accelerating", "decelerating")
  
  cat(sprintf("- **%s**: Mean earnings %s %.1f%% in the latest year", grp, direction, abs(chg)))
  if (!is.na(acc)) {
    cat(sprintf(" (%s). ", accel_word))
  } else {
    cat(". ")
  }
  cat(sprintf("90/10 ratio = %.2f\n", ratio))
}
```


## Technical Notes

**Survey Weights:**

All distribution diagnostics in this section use PUMS person weights (PWGTP) to produce population-representative estimates. This ensures the density curves, percentiles, and summary statistics reflect the actual population distribution, not the sample distribution.

**Why ridge plots over overlaid densities?**

Overlaid densities work for 2-3 years but become unreadable with more. Ridge plots handle many years cleanly and make temporal patterns obvious.

**Why track percentiles instead of just mean/median?**

Mean and median can both rise while inequality grows—if the 90th percentile rises faster than the 10th. The quantile plot catches this.

**What counts as meaningful acceleration?**

- `Accel` > ±2 percentage points is notable
- `90/10 Δ` > ±0.3 suggests meaningful inequality change
- Sustained patterns over multiple years matter more than single-year spikes

**Caveats:**

- Data represents the PUMA area, not just the city boundaries
- Small sample sizes in some government levels may produce noisy distributions
- Year 2020 is excluded due to COVID-related low response rates (no 1-year ACS released)
- Year 2022 is excluded due to PUMA boundary inconsistencies in tidycensus
- These diagnostics do not incorporate replicate weights for standard error estimation—use the main analysis tables for statistical inference


# Calculate Estimates

```{r}
#| label: calculate-estimates

# -----------------------------------------------------------------------------
# Function to calculate weighted estimates by government level
# -----------------------------------------------------------------------------
calc_gov_estimates <- function(data, cpi_tbl) {
  
  results_list <- purrr::map(base::unique(data$year), function(y) {
    year_data <- data[data$year == y, ]
    cpi_factor <- cpi_tbl$factor_to_base[cpi_tbl$year == y]
    if (base::length(cpi_factor) == 0L) cpi_factor <- 1
    
    year_svy <- srvyr::as_survey_rep(
      year_data,
      weights = PWGTP,
      repweights = dplyr::matches("^PWGTP\\d+$"),
      type = "JK1",
      scale = 4 / 80,
      rscales = base::rep(1, 80),
      mse = TRUE
    )
    
    stats <- year_svy |>
      srvyr::group_by(gov_level) |>
      srvyr::summarise(
        n_employees = srvyr::survey_total(1, vartype = "se"),
        mean_earnings = srvyr::survey_mean(earnings, vartype = "se"),
        median_earnings = srvyr::survey_median(earnings, vartype = "se"),
        .groups = "drop"
      )
    
    stats$year <- y
    stats$cpi_factor <- cpi_factor
    stats$mean_earnings_real <- stats$mean_earnings * cpi_factor
    stats$median_earnings_real <- stats$median_earnings * cpi_factor
    
    stats
  })
  
  dplyr::bind_rows(results_list)
}

# -----------------------------------------------------------------------------
# DERIVED: Results by government level (aggregated)
# -----------------------------------------------------------------------------
derived_gov_results <- calc_gov_estimates(derived_gov_employees, raw_cpi)

# -----------------------------------------------------------------------------
# Function to calculate overall estimates (all government combined)
# -----------------------------------------------------------------------------
calc_overall_estimates <- function(data, cpi_tbl) {
  
  results_list <- purrr::map(base::unique(data$year), function(y) {
    year_data <- data[data$year == y, ]
    cpi_factor <- cpi_tbl$factor_to_base[cpi_tbl$year == y]
    if (base::length(cpi_factor) == 0L) cpi_factor <- 1
    
    year_svy <- srvyr::as_survey_rep(
      year_data,
      weights = PWGTP,
      repweights = dplyr::matches("^PWGTP\\d+$"),
      type = "JK1",
      scale = 4 / 80,
      rscales = base::rep(1, 80),
      mse = TRUE
    )
    
    stats <- year_svy |>
      srvyr::summarise(
        n_employees = srvyr::survey_total(1, vartype = "se"),
        mean_earnings = srvyr::survey_mean(earnings, vartype = "se"),
        median_earnings = srvyr::survey_median(earnings, vartype = "se")
      )
    
    stats$year <- y
    stats$gov_level <- "All Government"
    stats$cpi_factor <- cpi_factor
    stats$mean_earnings_real <- stats$mean_earnings * cpi_factor
    stats$median_earnings_real <- stats$median_earnings * cpi_factor
    
    stats
  })
  
  dplyr::bind_rows(results_list)
}

# -----------------------------------------------------------------------------
# DERIVED: Overall results (aggregated)
# -----------------------------------------------------------------------------
derived_overall_results <- calc_overall_estimates(derived_gov_employees, raw_cpi)
```


# Government Employee Counts

```{r}
#| label: employee-counts-table

display_counts_wide <- derived_gov_results |>
  dplyr::select(year, gov_level, n_employees) |>
  tidyr::pivot_wider(
    names_from = gov_level,
    values_from = n_employees
  ) |>
  dplyr::arrange(year)

# Handle potentially missing columns
gov_cols <- c("Local Government", "State Government", "Federal Government")
for (col in gov_cols) {
  if (!col %in% names(display_counts_wide)) {
    display_counts_wide[[col]] <- NA_real_
  }
}

display_counts_wide$Total <- base::rowSums(
  display_counts_wide[, gov_cols],
  na.rm = TRUE
)

display_counts <- display_counts_wide |>
  dplyr::mutate(
    Year = base::as.character(year),
    Local = base::format(base::round(`Local Government`, 0), big.mark = ","),
    State = base::format(base::round(`State Government`, 0), big.mark = ","),
    Federal = base::format(base::round(`Federal Government`, 0), big.mark = ","),
    Total = base::format(base::round(Total, 0), big.mark = ",")
  ) |>
  dplyr::select(Year, Local, State, Federal, Total)

ft_counts <- flextable::flextable(display_counts)
ft_counts <- ds_style_flextable(
  ft_counts,
  title = base::paste0("Number of Government Employees: ", params$city, ", ", params$state, " Area")
)
ft_counts
```


# Mean Earnings by Government Level

Mean earnings for government employees (inflation-adjusted to `r params$base_year` dollars).

```{r}
#| label: mean-earnings-table

display_mean_wide <- derived_gov_results |>
  dplyr::select(year, gov_level, mean_earnings_real) |>
  tidyr::pivot_wider(
    names_from = gov_level,
    values_from = mean_earnings_real
  ) |>
  dplyr::arrange(year)

# Handle potentially missing columns
for (col in gov_cols) {
  if (!col %in% names(display_mean_wide)) {
    display_mean_wide[[col]] <- NA_real_
  }
}

display_mean <- display_mean_wide |>
  dplyr::mutate(
    Year = base::as.character(year),
    Local = base::ifelse(is.na(`Local Government`), "N/A", 
                         base::paste0("$", base::format(base::round(`Local Government`, 0), big.mark = ","))),
    State = base::ifelse(is.na(`State Government`), "N/A",
                         base::paste0("$", base::format(base::round(`State Government`, 0), big.mark = ","))),
    Federal = base::ifelse(is.na(`Federal Government`), "N/A",
                           base::paste0("$", base::format(base::round(`Federal Government`, 0), big.mark = ",")))
  ) |>
  dplyr::select(Year, Local, State, Federal)

ft_mean <- flextable::flextable(display_mean)
ft_mean <- ds_style_flextable(
  ft_mean,
  title = base::paste0(
    "Mean Earnings by Government Level: ", params$city, ", ", params$state,
    " Area (", params$base_year, " dollars)"
  )
)
ft_mean
```

```{r}
#| label: mean-earnings-chart
#| fig-width: 9
#| fig-height: 5

ggplot2::ggplot(derived_gov_results, ggplot2::aes(x = year, y = mean_earnings_real, color = gov_level)) +
  ggplot2::geom_line(linewidth = 1) +
  ggplot2::geom_point(size = 3) +
  ggplot2::scale_x_continuous(breaks = base::unique(derived_gov_results$year)) +
  ggplot2::scale_y_continuous(
    labels = function(x) base::paste0("$", base::format(x, big.mark = ","))
  ) +
  ggplot2::scale_color_manual(
    values = c(
      "Local Government" = "steelblue",
      "State Government" = "forestgreen",
      "Federal Government" = "darkorange"
    )
  ) +
  ggplot2::labs(
    title = base::paste0("Mean Earnings by Government Level: ", params$city, ", ", params$state, " Area"),
    subtitle = base::paste0("PUMS ", params$survey, " (", params$base_year, " dollars)"),
    x = "Year",
    y = "Mean Earnings",
    color = "Level",
    caption = "Source: ACS PUMS (weighted estimates)"
  )
```


# Median Earnings by Government Level

Median earnings for government employees (inflation-adjusted to `r params$base_year` dollars).

```{r}
#| label: median-earnings-table

display_median_wide <- derived_gov_results |>
  dplyr::select(year, gov_level, median_earnings_real) |>
  tidyr::pivot_wider(
    names_from = gov_level,
    values_from = median_earnings_real
  ) |>
  dplyr::arrange(year)

# Handle potentially missing columns
for (col in gov_cols) {
  if (!col %in% names(display_median_wide)) {
    display_median_wide[[col]] <- NA_real_
  }
}

display_median <- display_median_wide |>
  dplyr::mutate(
    Year = base::as.character(year),
    Local = base::ifelse(is.na(`Local Government`), "N/A",
                         base::paste0("$", base::format(base::round(`Local Government`, 0), big.mark = ","))),
    State = base::ifelse(is.na(`State Government`), "N/A",
                         base::paste0("$", base::format(base::round(`State Government`, 0), big.mark = ","))),
    Federal = base::ifelse(is.na(`Federal Government`), "N/A",
                           base::paste0("$", base::format(base::round(`Federal Government`, 0), big.mark = ",")))
  ) |>
  dplyr::select(Year, Local, State, Federal)

ft_median <- flextable::flextable(display_median)
ft_median <- ds_style_flextable(
  ft_median,
  title = base::paste0(
    "Median Earnings by Government Level: ", params$city, ", ", params$state,
    " Area (", params$base_year, " dollars)"
  )
)
ft_median
```

```{r}
#| label: median-earnings-chart
#| fig-width: 9
#| fig-height: 5

ggplot2::ggplot(derived_gov_results, ggplot2::aes(x = year, y = median_earnings_real, color = gov_level)) +
  ggplot2::geom_line(linewidth = 1) +
  ggplot2::geom_point(size = 3) +
  ggplot2::scale_x_continuous(breaks = base::unique(derived_gov_results$year)) +
  ggplot2::scale_y_continuous(
    labels = function(x) base::paste0("$", base::format(x, big.mark = ","))
  ) +
  ggplot2::scale_color_manual(
    values = c(
      "Local Government" = "steelblue",
      "State Government" = "forestgreen",
      "Federal Government" = "darkorange"
    )
  ) +
  ggplot2::labs(
    title = base::paste0("Median Earnings by Government Level: ", params$city, ", ", params$state, " Area"),
    subtitle = base::paste0("PUMS ", params$survey, " (", params$base_year, " dollars)"),
    x = "Year",
    y = "Median Earnings",
    color = "Level",
    caption = "Source: ACS PUMS (weighted estimates)"
  )
```


# Latest Year Comparison

Detailed comparison for `r base::max(params$years)`:

```{r}
#| label: latest-year-comparison

latest_year <- base::max(derived_gov_results$year)
display_latest <- derived_gov_results |>
  dplyr::filter(year == latest_year) |>
  dplyr::arrange(dplyr::desc(mean_earnings_real)) |>
  dplyr::mutate(
    `Government Level` = gov_level,
    Employees = base::format(base::round(n_employees, 0), big.mark = ","),
    `Mean Earnings` = base::paste0(
      "$", base::format(base::round(mean_earnings_real, 0), big.mark = ",")
    ),
    `Median Earnings` = base::paste0(
      "$", base::format(base::round(median_earnings_real, 0), big.mark = ",")
    )
  ) |>
  dplyr::select(`Government Level`, Employees, `Mean Earnings`, `Median Earnings`)

ft_latest <- flextable::flextable(display_latest)
ft_latest <- ds_style_flextable(
  ft_latest,
  title = base::paste0(
    "Government Employee Earnings (", latest_year, "): ",
    params$city, ", ", params$state, " Area"
  )
)
ft_latest
```


# All Government Combined

Overall statistics for all government employees (local + state + federal combined).

```{r}
#| label: overall-table

display_overall <- derived_overall_results |>
  dplyr::arrange(year) |>
  dplyr::mutate(
    Year = base::as.character(year),
    Employees = base::format(base::round(n_employees, 0), big.mark = ","),
    `Mean (Real)` = base::paste0(
      "$", base::format(base::round(mean_earnings_real, 0), big.mark = ",")
    ),
    `Median (Real)` = base::paste0(
      "$", base::format(base::round(median_earnings_real, 0), big.mark = ",")
    )
  ) |>
  dplyr::select(Year, Employees, `Mean (Real)`, `Median (Real)`)

ft_overall <- flextable::flextable(display_overall)
ft_overall <- ds_style_flextable(
  ft_overall,
  title = base::paste0(
    "All Government Employees: ", params$city, ", ", params$state,
    " Area (", params$base_year, " dollars)"
  )
)
ft_overall
```


# Export Data

```{r}
#| label: export

base::dir.create("out", showWarnings = FALSE, recursive = TRUE)

file_base <- base::paste0(
  "out/pums_gov_earnings_",
  base::tolower(base::gsub(" ", "_", params$city)), "_",
  params$state, "_",
  base::min(params$years), "_", base::max(params$years),
  "_", params$survey
)

base::saveRDS(derived_gov_results, base::paste0(file_base, "_by_level.rds"))
base::saveRDS(derived_overall_results, base::paste0(file_base, "_overall.rds"))

readr::write_csv(derived_gov_results, base::paste0(file_base, "_by_level.csv"))
readr::write_csv(derived_overall_results, base::paste0(file_base, "_overall.csv"))

writexl::write_xlsx(
  base::list(
    by_government_level = derived_gov_results,
    all_government = derived_overall_results,
    inflation_rate = derived_inflation_rate,
    cpi_factors = raw_cpi
  ),
  base::paste0(file_base, ".xlsx")
)
```

Data exported to `out/` directory.


# Notes

**Data Source:** ACS `r params$survey` PUMS data

**Years Analyzed:** `r paste(params$years, collapse = ", ")`

**Excluded Years:**

- **2020:** No regular 1-year ACS released due to COVID-related low response rates
- **2022:** PUMA boundary inconsistencies in tidycensus

**1-Year vs 5-Year Estimates:**

This analysis uses 1-year ACS estimates. Compared to 5-year estimates:

- **Advantage:** More recent data (2024 available now)
- **Disadvantage:** Larger standard errors (~3× those of 5-year estimates)
- **Disadvantage:** May not reliably cover smaller geographic areas

**Naming Convention:**

| Prefix | Meaning | Skew Check? |
|--------|---------|-------------|
| `raw_*` | Data from external source | YES (by year) |
| `derived_*` | Filtered/transformed | Depends on aggregation |
| `display_*` | Formatted for output | NO |

**Key Rule:** Check skewness on **raw, single-year data** within meaningful strata (year, government level). Never check skewness on stacked multi-year data or aggregated results.

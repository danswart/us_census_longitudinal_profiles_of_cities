---
title: "Government Employee Earnings Analysis (PUMS Microdata)"
subtitle: "By Level of Government: Local, State, Federal"
authors: 
  - name: "Dan Swart, CPA (ret)"
  - name: "Claude Sonnet 4.5"
date: today
date-format: long
# bibliography: manual-refs.bib
format:
  html:
    resources:
      - reference-backlinks.js
    include-after-body:    
      - text: |
          # <script type="text/javascript" src="reference-backlinks.js"></script>
    default: true         
    code-copy: true
    code-link: true        # This adds individual buttons
    code-fold: true        # Hide code by default, show on click
    code-summary: "Show the code"
    code-overflow: wrap
    code-block-bg: "#FAEBD7"
    code-block-border-left: "#31BAE9"
    embed-resources: false     # Fast for drafts. Override for sharing output
    include-in-header:
      - text: 
          <link href="https://fonts.googleapis.com/css2?family=Lato&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Montserrat&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Cabin&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Schoolbell&display=swap" rel="stylesheet">
      - header.html
    css:
      - swart.css
      - tachyons.min.css
      - r-colors.css
    fontsize: 18pt
    lightbox: true
    page-layout: full
    fig-width: 13
    fig-height: 8
    fig-dpi: 300
    html-math-method: katex
    df-print: paged
    toc: true
    toc-float: true
    citeproc: true
    link-citations: true
    linestretch: 1.0
    
    
    
  typst:
    # fig-width: 13
    E fig-height: 8
    fig-dpi: 300
    margin:
      x: 1in
      y: 1in
    toc: true
    fontsize: 16pt
    mainfont: "Cabin"
  

    
  revealjs:
    slide-number: true
    transition: fade
    code-overflow: wrap
    center: true
    smaller: true
    scrollable: true
    chalkboard: true
    multiplex: false
    theme: solarized
    reference-location: margin
    logo: img/red-cross-640-435.png
    footer: "Footer text"
    code-block-height: 650px



  # docx:
  #   highlight-style: github
  #   fig_caption: true



editor: source

quarto:
  render:
    cache-refresh: true


# for .qmd filesd
execute:
  echo: true
  message: false
  warning: false
  eval: true
  fig-width: 13
  fig-height: 8


# for .rmd files
knitr:
  opts_chunk:
    echo: true
    error: false
    warning: false
    message: false
    cache: false


---




```{r}
#| label: params
#| include: false

# =============================================================================
# PARAMETERS - CHANGE THESE FOR A DIFFERENT CITY/YEARS
# =============================================================================

params <- base::list(
  city       = "Schertz",
  state      = "TX",
  # NOTE: 2022 excluded - tidycensus blocks it due to PUMA boundary inconsistencies
  # See: https://github.com/walkerke/tidycensus/issues/555
  years      = c(2019, 2020, 2021, 2023),
  min_age    = 20L,
  survey     = "acs5",
  base_year  = 2023,
  cache_dir  = "cache/pums_gov"
)

# =============================================================================
```

```{r}
#| label: setup
#| include: false

# -----------------------------------------------------------------------------
# Package verification
# -----------------------------------------------------------------------------
required_pkgs <- c(
  "tidycensus", "tigris", "dplyr", "purrr", "tibble", "stringr", "tidyr",
  "digest", "lubridate", "quantmod", "zoo", "ggplot2", "flextable",
  "srvyr", "survey", "readr", "writexl", "sf", "mapview", "httr"
)

missing <- required_pkgs[
  !base::vapply(required_pkgs, requireNamespace, logical(1L), quietly = TRUE)
]

if (base::length(missing) > 0L) {
  base::stop("Install missing packages:\n", base::paste(missing, collapse = ", "))
}

# -----------------------------------------------------------------------------
# CRITICAL: tidycensus must be loaded with library() for pums_variables to work
# -----------------------------------------------------------------------------
base::suppressPackageStartupMessages({
  library(tidycensus)
  library(tigris)
})

# -----------------------------------------------------------------------------
# Options
# -----------------------------------------------------------------------------
base::options(

  tigris_use_cache = TRUE,
  tidycensus.show_progress = FALSE,
  survey.lonely.psu = "adjust"
)

# Suppress httr download progress bars
httr::set_config(httr::config(noprogress = TRUE))

# Suppress mapview messages
mapview::mapviewOptions(verbose = FALSE)

# Select OpenStreetMap as default view
mapview::mapviewOptions(basemaps = "OpenStreetMap")

# Force dplyr's select to take precedence
select <- dplyr::select
filter <- dplyr::filter


options(scipen = 999)
options(qic.clshade = T) # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.linecol = 'black') # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.signalcol = "firebrick") # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.targetcol = "purple") # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(DT.options = list(dom = 'pBlfrti')) # Add buttons, filtering, and top (t) pagination controls
options(shiny.maxRequestSize = 50 * 1024^2) # Set upload maximum to 50 MB
options(tigris_use_cache = TRUE)
options(device = "RStudioGD") 


# Set global theme for consistent plots
ggplot2::theme_set(
  ggplot2::theme_minimal(base_size = 20) +
    ggplot2::theme(
      plot.title.position = "plot",
      plot.title = ggtext::element_textbox_simple(
        family = "Cabin",
        face = "bold",
        color = "darkgreen",
        size = 16,
        fill = "yellow",
        lineheight = 0.9,
        padding = ggplot2::margin(5.5, 5.5, 0.0, 5.5),
        margin = ggplot2::margin(0, 0, 5.5, 0)
      ),
      plot.subtitle = ggtext::element_textbox_simple(
        family = "Cabin",
        color = "darkgreen",
        face = "bold",
        size = 14,
        fill = "yellow",
        lineheight = 0.9,
        padding = ggplot2::margin(5.5, 5.5, 5.5, 5.5),
        margin = ggplot2::margin(0.0, 0, 5.5, 0)
      ),
      plot.caption = ggtext::element_markdown(
        family = "Cabin",
        size = 14,
        hjust = 1,
        color = "darkblue",
        face = "italic",
        fill = "yellow",
        lineheight = 1.0
      ),
      axis.text.x = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 12,
        angle = 45,
        hjust = 1
      ),
        # ggplot2::element_blank(),
      axis.title.x = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 14),
        # ggplot2::element_blank(),
      axis.text.y = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 12,
        angle = 45,
        hjust = 1
      ),
        # ggplot2::element_blank(),
      axis.title.y = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 12),
        # ggplot2::element_blank(),
      strip.text = ggtext::element_markdown(
        family = "Cabin",
        color = "black",
        size = 12,
        face = "italic",
        margin = ggplot2::margin(2, 0, 0.5, 0, "lines")
      ),
      axis.text = ggtext::element_markdown(
        family = "Cabin",
        color = "black"),
      panel.background = ggplot2::element_rect(fill = "white", color = NA),
      plot.background = ggplot2::element_rect(fill = "white", color = NA),
      legend.position = "none",
      panel.spacing.x = grid::unit(1.5, "cm"),
      panel.spacing.y = grid::unit(1.5, "cm"),
      plot.margin = ggplot2::margin(20, 20, 20, 20, "pt")
    )
)


# Flextable defaults:
flextable::set_flextable_defaults(
  font.size = 14, 
  font.family = "Cabin",
  font.color = "black",
  table.layout = "fixed",
  border.color = "darkgray",
  padding.top = 3, padding.bottom = 3,
  padding.left = 4, padding.right = 4,
  line_spacing = 1.3,
  digits = 2,
  decimal.mark = ".",
  big.mark = " ",
  na_str = "<na>",
  post_process_html = identity,
  post_process_docx = identity
)


  
# Set seed for reproducibility
base::set.seed(123)






```

```{r}
#| label: helper-functions
#| include: false

# -----------------------------------------------------------------------------
# Caching utilities
# -----------------------------------------------------------------------------

ds_cache_path <- function(cache_dir, key, ext = "rds") {
  base::dir.create(cache_dir, showWarnings = FALSE, recursive = TRUE)
  base::file.path(cache_dir, base::paste0(key, ".", ext))
}

ds_cache_key <- function(prefix, params) {
  digest::digest(base::list(prefix = prefix, params = params), algo = "xxhash64")
}

ds_cache_read <- function(path) {
  if (base::file.exists(path)) base::readRDS(path) else NULL
}

ds_cache_write <- function(x, path) {
  base::dir.create(base::dirname(path), showWarnings = FALSE, recursive = TRUE)
  base::saveRDS(x, path)
  base::invisible(x)
}

# -----------------------------------------------------------------------------
# Find PUMAs containing a city (spatial intersection)
# -----------------------------------------------------------------------------

ds_get_city_pumas <- function(city, state, year = 2020, cache_dir) {
  key <- ds_cache_key("city_pumas", base::list(city = city, state = state, year = year))
  path <- ds_cache_path(cache_dir, key)
  cached <- ds_cache_read(path)
  if (!base::is.null(cached)) return(cached)
  
  # Get PUMA boundaries (suppress download messages)
  pumas <- base::suppressMessages(
    tigris::pumas(state = state, year = year, progress_bar = FALSE)
  )
  
  # Get place (city) boundaries
  places <- base::suppressMessages(
    tigris::places(state = state, year = year, progress_bar = FALSE)
  )
  
  # Find the city
  city_pattern <- base::paste0("^", city, " city")
  city_sf <- places[base::grepl(city_pattern, places$NAME, ignore.case = TRUE), ]
  
  if (base::nrow(city_sf) == 0L) {
    city_sf <- places[base::grepl(
      base::paste0("^", city, "$"),
      places$NAME,
      ignore.case = TRUE
    ), ]
  }
  
  if (base::nrow(city_sf) == 0L) {
    base::stop(
      "City '", city, "' not found in ", state, ". ",
      "Check spelling or try a nearby larger city."
    )
  }
  
  # Find PUMAs that intersect with the city
  city_sf <- sf::st_transform(city_sf, sf::st_crs(pumas))
  intersecting <- base::suppressMessages(
    sf::st_intersects(pumas, city_sf, sparse = FALSE)
  )
  city_pumas <- pumas[base::apply(intersecting, 1, base::any), ]
  
  if (base::nrow(city_pumas) == 0L) {
    base::stop("No PUMAs found intersecting '", city, "'. This shouldn't happen.")
  }
  
  # Extract PUMA codes
  puma_col <- base::grep("^PUMACE", base::names(city_pumas), value = TRUE)[1L]
  puma_codes <- city_pumas[[puma_col]]
  
  result <- base::list(
    puma_codes = puma_codes,
    puma_names = city_pumas$NAMELSAD20,
    city_name = city_sf$NAME[1L],
    n_pumas = base::length(puma_codes)
  )
  
  ds_cache_write(result, path)
}

# -----------------------------------------------------------------------------
# PUMS data retrieval with COW (Class of Worker) variable
# -----------------------------------------------------------------------------

ds_get_pums_gov_earnings <- function(city, state, puma_codes, year, min_age = 20L,
                                     survey = "acs5", cache_dir) {
  key <- ds_cache_key("pums_gov_earnings_v5", base::list(
    city = city, state = state, puma_codes = puma_codes,
    year = year, min_age = min_age, survey = survey
  ))
  path <- ds_cache_path(cache_dir, key)
  cached <- ds_cache_read(path)
  if (!base::is.null(cached)) return(cached)
  
  # PUMS variables:
  # AGEP = Age
  # WAGP = Wages/salary income
  # SEMP = Self-employment income
  # COW = Class of Worker
  # PUMA = Public Use Microdata Area
  
  pums_vars <- base::c("AGEP", "WAGP", "SEMP", "COW", "PUMA")
  
  # Build filter for age
  age_filter <- base::list(AGEP = min_age:99L)
  
  # Suppress ALL download output including httr progress bars
  # sink() captures stdout; also redirect stderr
  tmp_file <- base::tempfile()
  tmp_err <- base::tempfile()
  
  # Save current connections
  base::sink(tmp_file, type = "output")
  base::sink(tmp_err, type = "message")
  
  raw <- base::tryCatch({
    result <- tidycensus::get_pums(
      variables        = pums_vars,
      state            = state,
      year             = year,
      survey           = survey,
      variables_filter = age_filter,
      rep_weights      = "person",
      recode           = TRUE,
      show_call        = FALSE
    )
    # Restore sinks
    base::sink(type = "message")
    base::sink(type = "output")
    base::unlink(base::c(tmp_file, tmp_err))
    result
  }, error = function(e) {
    # Restore sinks on error
    base::sink(type = "message")
    base::sink(type = "output")
    base::unlink(base::c(tmp_file, tmp_err))
    base::stop(e)
  })
  
  # Handle case where download failed
  if (base::is.null(raw) || base::nrow(raw) == 0L) {
    base::warning("get_pums returned no data for year ", year)
    return(NULL)
  }
  
  # Filter to PUMAs containing the city
  raw <- raw[raw$PUMA %in% puma_codes, ]
  
  if (base::nrow(raw) == 0L) {
    base::warning("No PUMS records found for ", city, " PUMAs in year ", year)
    return(NULL)
  }
  
  # Calculate total earnings (wages + self-employment)
  raw$earnings <- base::as.numeric(raw$WAGP) + base::as.numeric(raw$SEMP)
  raw$earnings <- base::ifelse(raw$earnings < 0, 0, raw$earnings)
  
  # Create government level labels
  # With recode=TRUE, COW_label contains text like "Local government employee"
  if ("COW_label" %in% base::names(raw)) {
    raw$gov_level <- base::ifelse(
      base::grepl("Local government", raw$COW_label, ignore.case = TRUE), "Local Government",
      base::ifelse(
        base::grepl("State government", raw$COW_label, ignore.case = TRUE), "State Government",
        base::ifelse(
          base::grepl("Federal government", raw$COW_label, ignore.case = TRUE), "Federal Government",
          NA_character_
        )
      )
    )
  } else {
    # Fallback to COW codes if no label column
    raw$gov_level <- base::ifelse(
      raw$COW %in% base::c("3", 3L), "Local Government",
      base::ifelse(
        raw$COW %in% base::c("4", 4L), "State Government",
        base::ifelse(
          raw$COW %in% base::c("5", 5L), "Federal Government",
          NA_character_
        )
      )
    )
  }
  
  # Add year column
  raw$year <- year
  
  # Convert factor columns to character to avoid bind_rows issues across years
  factor_cols <- base::names(raw)[base::vapply(raw, base::is.factor, logical(1L))]
  for (col in factor_cols) {
    raw[[col]] <- base::as.character(raw[[col]])
  }
  
  # Save to cache and return
  ds_cache_write(raw, path)
  return(raw)
}

# -----------------------------------------------------------------------------
# CPI / Inflation
# -----------------------------------------------------------------------------

ds_get_cpi_annual <- function(start_year, end_year, base_year, cache_dir) {
  key <- ds_cache_key("cpi_annual", base::list(
    start_year = start_year, end_year = end_year, base_year = base_year
  ))
  path <- ds_cache_path(cache_dir, key)
  cached <- ds_cache_read(path)
  if (!base::is.null(cached)) return(cached)
  
  # Suppress any download output
  xt <- base::suppressMessages(base::suppressWarnings(
    quantmod::getSymbols("CPIAUCSL", src = "FRED", auto.assign = FALSE)
  ))
  
  df <- tibble::tibble(
    date = base::as.Date(zoo::index(xt)),
    cpi  = base::as.numeric(xt[, 1L])
  )
  df$year <- lubridate::year(df$date)
  df <- df[df$year >= start_year & df$year <= end_year, ]
  
  annual <- dplyr::summarise(
    dplyr::group_by(df, year),
    cpi_annual_avg = base::mean(cpi, na.rm = TRUE),
    .groups = "drop"
  )
  
  base_cpi <- annual$cpi_annual_avg[annual$year == base_year]
  if (base::length(base_cpi) != 1L) {
    base::stop("Base year CPI not found for year ", base_year)
  }
  
  annual$base_year <- base_year
  annual$factor_to_base <- base_cpi / annual$cpi_annual_avg
  
  ds_cache_write(annual, path)
}

# -----------------------------------------------------------------------------
# Flextable styling
# -----------------------------------------------------------------------------

ds_style_flextable <- function(ft, title = NULL) {
  if (!base::is.null(title)) {
    ft <- flextable::add_header_lines(ft, values = title)
    ft <- flextable::color(ft, i = 1, part = "header", color = "blue")
    ft <- flextable::italic(ft, i = 1, part = "header")
    ft <- flextable::align(ft, i = 1, part = "header", align = "left")
    ft <- flextable::fontsize(ft, i = 1, part = "header", size = 12)
    ft <- flextable::bg(ft, i = 1, part = "header", bg = "white")
    ft <- flextable::bg(ft, i = 2, part = "header", bg = "palegreen")
  } else {
    ft <- flextable::bg(ft, i = 1, part = "header", bg = "palegreen")
  }
  ft <- flextable::autofit(ft)
  ft
}
```

# Overview

This document analyzes earnings for **government employees** (adults `r params$min_age`+) in the **`r params$city`, `r params$state` area** using PUMS microdata, broken down by level of government.

**Class of Worker (COW) Codes:**

| Code | Description |
|------|-------------|
| 1 | Private for-profit employee |
| 2 | Private not-for-profit employee |
| 3 | **Local government employee** |
| 4 | **State government employee** |
| 5 | **Federal government employee** |
| 6-9 | Self-employed and unpaid family |

**This analysis focuses on COW codes 3, 4, and 5** (government employees only).


# PUMA Identification

```{r}
#| label: find-pumas

# Find PUMAs containing the city
city_puma_info <- ds_get_city_pumas(
  city      = params$city,
  state     = params$state,
  year      = 2020,
  cache_dir = params$cache_dir
)

puma_codes <- city_puma_info$puma_codes
```

**`r params$city`** is located in **`r city_puma_info$n_pumas`** PUMA(s):

```{r}
#| label: puma-table

puma_display <- tibble::tibble(
  `PUMA Code` = city_puma_info$puma_codes,
  `PUMA Name` = city_puma_info$puma_names
)

ft_puma <- flextable::flextable(puma_display)
ft_puma <- ds_style_flextable(
  ft_puma,
  title = base::paste0("PUMAs Containing ", params$city, ", ", params$state)
)
ft_puma
```

```{r}
#| label: spatial-data
#| include: false

# Get spatial data for mapping (cached by tigris)
pumas_sf <- base::suppressMessages(
  tigris::pumas(state = params$state, year = 2020, progress_bar = FALSE)
)
places_sf <- base::suppressMessages(
  tigris::places(state = params$state, year = 2020, progress_bar = FALSE)
)

# Find the city boundary
city_pattern <- base::paste0("^", params$city, " city")
city_sf <- places_sf[base::grepl(city_pattern, places_sf$NAME, ignore.case = TRUE), ]
if (base::nrow(city_sf) == 0L) {
  city_sf <- places_sf[base::grepl(
    base::paste0("^", params$city, "$"), places_sf$NAME, ignore.case = TRUE
  ), ]
}

# Get the PUMAs containing the city
puma_col <- base::grep("^PUMACE", base::names(pumas_sf), value = TRUE)[1L]
city_pumas_sf <- pumas_sf[pumas_sf[[puma_col]] %in% puma_codes, ]

# Find major cities within the PUMAs
places_in_pumas <- base::suppressMessages(
  places_sf[sf::st_intersects(places_sf, city_pumas_sf, sparse = FALSE)[, 1], ]
)
places_in_pumas <- places_in_pumas[
  base::grepl("city|town", places_in_pumas$NAMELSAD, ignore.case = TRUE),
]

places_to_label <- NULL
if (base::nrow(places_in_pumas) > 0L) {
  places_in_pumas <- places_in_pumas[base::order(-places_in_pumas$ALAND), ]
  places_in_pumas <- places_in_pumas[
    !base::grepl(base::paste0("^", params$city), places_in_pumas$NAME, ignore.case = TRUE),
  ]
  if (base::nrow(places_in_pumas) > 0L) {
    places_to_label <- utils::head(places_in_pumas, 6)
  }
}
```

```{r}
#| label: puma-map
#| fig-height: 6

# Create interactive map with mapview
# Add PUMA label to city_pumas_sf for popup
city_pumas_sf$puma_label <- base::paste0("PUMA ", city_pumas_sf[[puma_col]])

# Add city name for popup
city_sf$label <- params$city

# Build the interactive map
m <- mapview::mapview(
  city_pumas_sf,
  col.regions = "lightblue",
  color = "steelblue",
  alpha.regions = 0.3,
  layer.name = "PUMA Coverage",
  label = city_pumas_sf$puma_label
)

# Add target city
m <- m + mapview::mapview(
  city_sf,
  col.regions = "tomato",
  color = "darkred",
  alpha.regions = 0.5,
  layer.name = base::paste0(params$city, " (Target)"),
  label = city_sf$label
)

# Add other cities in PUMA if available
if (!base::is.null(places_to_label) && base::nrow(places_to_label) > 0L) {
  places_to_label$label <- places_to_label$NAME
  m <- m + mapview::mapview(
    places_to_label,
    col.regions = "gray70",
    color = "gray50",
    alpha.regions = 0.2,
    layer.name = "Other Cities in PUMA",
    label = places_to_label$label
  )
}

m
```

*Interactive map: Use mouse wheel to zoom, click layers to see details. The blue shaded area represents the PUMA(s) from which PUMS data is drawn.*

**Other cities/towns included in the PUMA data area:**

```{r}
#| label: cities-in-puma-table

if (!base::is.null(places_to_label) && base::nrow(places_to_label) > 0L) {
  cities_display <- tibble::tibble(
    City = places_to_label$NAME,
    Type = base::gsub(".*(city|town).*", "\\1", places_to_label$NAMELSAD, ignore.case = TRUE)
  )
  
  ft_cities <- flextable::flextable(cities_display)
  ft_cities <- ds_style_flextable(
    ft_cities,
    title = base::paste0("Major Cities/Towns in ", params$city, " PUMA Area")
  )
  ft_cities
} else {
  base::cat("No other major cities found in the PUMA area.")
}
```


# Data Retrieval

```{r}
#| label: pull-pums

# Pull PUMS data for each year (uses caching - fast after first run)
pums_list <- purrr::map(params$years, function(y) {
  tryCatch({
    ds_get_pums_gov_earnings(
      city       = params$city,
      state      = params$state,
      puma_codes = puma_codes,
      year       = y,
      min_age    = params$min_age,
      survey     = params$survey,
      cache_dir  = params$cache_dir
    )
  }, error = function(e) {
    base::warning("Failed to get PUMS for year ", y, ": ", e$message)
    NULL
  })
})

# Remove failed years
pums_list <- pums_list[!base::vapply(pums_list, base::is.null, logical(1L))]

# Combine all years
pums_all <- dplyr::bind_rows(pums_list)
```

```{r}
#| label: cpi-data

# Get CPI for inflation adjustment
cpi_tbl <- ds_get_cpi_annual(
  start_year = base::min(params$years),
  end_year   = base::max(params$years),
  base_year  = params$base_year,
  cache_dir  = params$cache_dir
)

# Create inflation rate data frame
inflation_rate <- cpi_tbl |>
  dplyr::arrange(year) |>
  dplyr::mutate(
    cpi_prior = dplyr::lag(cpi_annual_avg),
    inflation_pct = (cpi_annual_avg - cpi_prior) / cpi_prior * 100
  ) |>
  dplyr::filter(!base::is.na(inflation_pct)) |>
  dplyr::select(year, cpi_annual_avg, inflation_pct)
```

```{r}
#| label: calculate-estimates

# If earnings column doesn't exist, create it
if (!"earnings" %in% base::names(pums_all)) {
  pums_all$earnings <- base::as.numeric(pums_all$WAGP) + base::as.numeric(pums_all$SEMP)
  pums_all$earnings <- base::ifelse(pums_all$earnings < 0, 0, pums_all$earnings)
}

# If gov_level column doesn't exist, create it
if (!"gov_level" %in% base::names(pums_all)) {
  if ("COW_label" %in% base::names(pums_all)) {
    pums_all$gov_level <- base::ifelse(
      base::grepl("Local government", pums_all$COW_label, ignore.case = TRUE), "Local Government",
      base::ifelse(
        base::grepl("State government", pums_all$COW_label, ignore.case = TRUE), "State Government",
        base::ifelse(
          base::grepl("Federal government", pums_all$COW_label, ignore.case = TRUE), "Federal Government",
          NA_character_
        )
      )
    )
  } else if ("COW" %in% base::names(pums_all)) {
    pums_all$gov_level <- base::ifelse(
      pums_all$COW %in% base::c("3", 3L), "Local Government",
      base::ifelse(
        pums_all$COW %in% base::c("4", 4L), "State Government",
        base::ifelse(
          pums_all$COW %in% base::c("5", 5L), "Federal Government",
          NA_character_
        )
      )
    )
  } else {
    base::stop("Neither COW nor COW_label column found in PUMS data")
  }
}

# Filter to government employees only (COW 3, 4, 5)
gov_employees <- pums_all |>
  dplyr::filter(!base::is.na(gov_level), earnings > 0)

# Function to calculate weighted estimates by government level
calc_gov_estimates <- function(data, cpi_tbl) {
  
  results_list <- purrr::map(base::unique(data$year), function(y) {
    year_data <- data[data$year == y, ]
    cpi_factor <- cpi_tbl$factor_to_base[cpi_tbl$year == y]
    if (base::length(cpi_factor) == 0L) cpi_factor <- 1
    
    # Create survey design
    year_svy <- srvyr::as_survey_rep(
      year_data,
      weights = PWGTP,
      repweights = dplyr::matches("^PWGTP\\d+$"),
      type = "JK1",
      scale = 4 / 80,
      rscales = base::rep(1, 80),
      mse = TRUE
    )
    
    # Calculate stats by government level
    stats <- year_svy |>
      srvyr::group_by(gov_level) |>
      srvyr::summarise(
        n_employees = srvyr::survey_total(1, vartype = "se"),
        mean_earnings = srvyr::survey_mean(earnings, vartype = "se"),
        median_earnings = srvyr::survey_median(earnings, vartype = "se"),
        .groups = "drop"
      )
    
    stats$year <- y
    stats$cpi_factor <- cpi_factor
    stats$mean_earnings_real <- stats$mean_earnings * cpi_factor
    stats$median_earnings_real <- stats$median_earnings * cpi_factor
    
    stats
  })
  
  dplyr::bind_rows(results_list)
}

# Calculate estimates
gov_results <- calc_gov_estimates(gov_employees, cpi_tbl)

# Also calculate overall stats (all government combined)
calc_overall_estimates <- function(data, cpi_tbl) {
  
  results_list <- purrr::map(base::unique(data$year), function(y) {
    year_data <- data[data$year == y, ]
    cpi_factor <- cpi_tbl$factor_to_base[cpi_tbl$year == y]
    if (base::length(cpi_factor) == 0L) cpi_factor <- 1
    
    year_svy <- srvyr::as_survey_rep(
      year_data,
      weights = PWGTP,
      repweights = dplyr::matches("^PWGTP\\d+$"),
      type = "JK1",
      scale = 4 / 80,
      rscales = base::rep(1, 80),
      mse = TRUE
    )
    
    stats <- year_svy |>
      srvyr::summarise(
        n_employees = srvyr::survey_total(1, vartype = "se"),
        mean_earnings = srvyr::survey_mean(earnings, vartype = "se"),
        median_earnings = srvyr::survey_median(earnings, vartype = "se")
      )
    
    stats$year <- y
    stats$gov_level <- "All Government"
    stats$cpi_factor <- cpi_factor
    stats$mean_earnings_real <- stats$mean_earnings * cpi_factor
    stats$median_earnings_real <- stats$median_earnings * cpi_factor
    
    stats
  })
  
  dplyr::bind_rows(results_list)
}

overall_results <- calc_overall_estimates(gov_employees, cpi_tbl)
```


# Government Employee Counts

Number of government employees (weighted) in the `r params$city` PUMA area.

```{r}
#| label: employee-counts-table

counts_wide <- gov_results |>
  dplyr::select(year, gov_level, n_employees) |>
  tidyr::pivot_wider(
    names_from = gov_level,
    values_from = n_employees
  ) |>
  dplyr::arrange(year)

# Add total
counts_wide$Total <- base::rowSums(
  counts_wide[, base::c("Local Government", "State Government", "Federal Government")],
  na.rm = TRUE
)

counts_display <- counts_wide |>
  dplyr::mutate(
    Year = base::as.character(year),
    Local = base::format(base::round(`Local Government`, 0), big.mark = ","),
    State = base::format(base::round(`State Government`, 0), big.mark = ","),
    Federal = base::format(base::round(`Federal Government`, 0), big.mark = ","),
    Total = base::format(base::round(Total, 0), big.mark = ",")
  ) |>
  dplyr::select(Year, Local, State, Federal, Total)

ft_counts <- flextable::flextable(counts_display)
ft_counts <- ds_style_flextable(
  ft_counts,
  title = base::paste0("Government Employees: ", params$city, ", ", params$state, " Area")
)
ft_counts
```

```{r}
#| label: employee-counts-chart
#| fig-width: 9
#| fig-height: 5

ggplot2::ggplot(gov_results, ggplot2::aes(x = year, y = n_employees, fill = gov_level)) +
  ggplot2::geom_col(position = "dodge", width = 0.7) +
  ggplot2::scale_x_continuous(breaks = base::unique(gov_results$year)) +
  ggplot2::scale_y_continuous(
    labels = function(x) base::format(x, big.mark = ",")
  ) +
  ggplot2::scale_fill_manual(
    values = base::c(
      "Local Government" = "steelblue",
      "State Government" = "forestgreen",
      "Federal Government" = "darkorange"
    )
  ) +
  ggplot2::labs(
    title = base::paste0("Government Employees by Level: ", params$city, ", ", params$state, " Area"),
    subtitle = base::paste0("PUMS ", params$survey, " estimates"),
    x = "Year",
    y = "Number of Employees",
    fill = "Level",
    caption = "Source: ACS PUMS (weighted estimates)"
  ) +
  ggplot2::theme_minimal(base_size = 12) +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
    plot.title = ggplot2::element_text(face = "bold"),
    legend.position = "bottom"
  )
```


# Mean Earnings by Government Level

Mean earnings for government employees (inflation-adjusted to `r params$base_year` dollars).

```{r}
#| label: mean-earnings-table

mean_wide <- gov_results |>
  dplyr::select(year, gov_level, mean_earnings_real) |>
  tidyr::pivot_wider(
    names_from = gov_level,
    values_from = mean_earnings_real
  ) |>
  dplyr::arrange(year)

mean_display <- mean_wide |>
  dplyr::mutate(
    Year = base::as.character(year),
    Local = base::paste0("$", base::format(base::round(`Local Government`, 0), big.mark = ",")),
    State = base::paste0("$", base::format(base::round(`State Government`, 0), big.mark = ",")),
    Federal = base::paste0("$", base::format(base::round(`Federal Government`, 0), big.mark = ","))
  ) |>
  dplyr::select(Year, Local, State, Federal)

ft_mean <- flextable::flextable(mean_display)
ft_mean <- ds_style_flextable(
  ft_mean,
  title = base::paste0(
    "Mean Earnings by Government Level: ", params$city, ", ", params$state,
    " Area (", params$base_year, " dollars)"
  )
)
ft_mean
```

```{r}
#| label: mean-earnings-chart
#| fig-width: 9
#| fig-height: 5

ggplot2::ggplot(gov_results, ggplot2::aes(x = year, y = mean_earnings_real, color = gov_level)) +
  ggplot2::geom_line(linewidth = 1) +
  ggplot2::geom_point(size = 3) +
  ggplot2::scale_x_continuous(breaks = base::unique(gov_results$year)) +
  ggplot2::scale_y_continuous(
    labels = function(x) base::paste0("$", base::format(x, big.mark = ","))
  ) +
  ggplot2::scale_color_manual(
    values = base::c(
      "Local Government" = "steelblue",
      "State Government" = "forestgreen",
      "Federal Government" = "darkorange"
    )
  ) +
  ggplot2::labs(
    title = base::paste0("Mean Earnings by Government Level: ", params$city, ", ", params$state, " Area"),
    subtitle = base::paste0("PUMS ", params$survey, " (", params$base_year, " dollars)"),
    x = "Year",
    y = "Mean Earnings",
    color = "Level",
    caption = "Source: ACS PUMS (weighted estimates)"
  ) +
  ggplot2::theme_minimal(base_size = 12) +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
    plot.title = ggplot2::element_text(face = "bold"),
    legend.position = "bottom"
  )
```


# Median Earnings by Government Level

Median earnings for government employees (inflation-adjusted to `r params$base_year` dollars).

```{r}
#| label: median-earnings-table

median_wide <- gov_results |>
  dplyr::select(year, gov_level, median_earnings_real) |>
  tidyr::pivot_wider(
    names_from = gov_level,
    values_from = median_earnings_real
  ) |>
  dplyr::arrange(year)

median_display <- median_wide |>
  dplyr::mutate(
    Year = base::as.character(year),
    Local = base::paste0("$", base::format(base::round(`Local Government`, 0), big.mark = ",")),
    State = base::paste0("$", base::format(base::round(`State Government`, 0), big.mark = ",")),
    Federal = base::paste0("$", base::format(base::round(`Federal Government`, 0), big.mark = ","))
  ) |>
  dplyr::select(Year, Local, State, Federal)

ft_median <- flextable::flextable(median_display)
ft_median <- ds_style_flextable(
  ft_median,
  title = base::paste0(
    "Median Earnings by Government Level: ", params$city, ", ", params$state,
    " Area (", params$base_year, " dollars)"
  )
)
ft_median
```

```{r}
#| label: median-earnings-chart
#| fig-width: 9
#| fig-height: 5

ggplot2::ggplot(gov_results, ggplot2::aes(x = year, y = median_earnings_real, color = gov_level)) +
  ggplot2::geom_line(linewidth = 1) +
  ggplot2::geom_point(size = 3) +
  ggplot2::scale_x_continuous(breaks = base::unique(gov_results$year)) +
  ggplot2::scale_y_continuous(
    labels = function(x) base::paste0("$", base::format(x, big.mark = ","))
  ) +
  ggplot2::scale_color_manual(
    values = base::c(
      "Local Government" = "steelblue",
      "State Government" = "forestgreen",
      "Federal Government" = "darkorange"
    )
  ) +
  ggplot2::labs(
    title = base::paste0("Median Earnings by Government Level: ", params$city, ", ", params$state, " Area"),
    subtitle = base::paste0("PUMS ", params$survey, " (", params$base_year, " dollars)"),
    x = "Year",
    y = "Median Earnings",
    color = "Level",
    caption = "Source: ACS PUMS (weighted estimates)"
  ) +
  ggplot2::theme_minimal(base_size = 12) +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
    plot.title = ggplot2::element_text(face = "bold"),
    legend.position = "bottom"
  )
```


# Latest Year Comparison

Detailed comparison for `r base::max(params$years)`:

```{r}
#| label: latest-year-comparison

latest_year <- base::max(gov_results$year)
latest_data <- gov_results |>
  dplyr::filter(year == latest_year) |>
  dplyr::arrange(dplyr::desc(mean_earnings_real))

latest_display <- latest_data |>
  dplyr::mutate(
    `Government Level` = gov_level,
    Employees = base::format(base::round(n_employees, 0), big.mark = ","),
    `Mean Earnings` = base::paste0(
      "$", base::format(base::round(mean_earnings_real, 0), big.mark = ",")
    ),
    `Median Earnings` = base::paste0(
      "$", base::format(base::round(median_earnings_real, 0), big.mark = ",")
    )
  ) |>
  dplyr::select(`Government Level`, Employees, `Mean Earnings`, `Median Earnings`)

ft_latest <- flextable::flextable(latest_display)
ft_latest <- ds_style_flextable(
  ft_latest,
  title = base::paste0(
    "Government Employee Earnings (", latest_year, "): ",
    params$city, ", ", params$state, " Area"
  )
)
ft_latest
```


# All Government Combined

Overall statistics for all government employees (local + state + federal combined).

```{r}
#| label: overall-table

overall_display <- overall_results |>
  dplyr::arrange(year) |>
  dplyr::mutate(
    Year = base::as.character(year),
    Employees = base::format(base::round(n_employees, 0), big.mark = ","),
    `Mean (Real)` = base::paste0(
      "$", base::format(base::round(mean_earnings_real, 0), big.mark = ",")
    ),
    `Median (Real)` = base::paste0(
      "$", base::format(base::round(median_earnings_real, 0), big.mark = ",")
    )
  ) |>
  dplyr::select(Year, Employees, `Mean (Real)`, `Median (Real)`)

ft_overall <- flextable::flextable(overall_display)
ft_overall <- ds_style_flextable(
  ft_overall,
  title = base::paste0(
    "All Government Employees: ", params$city, ", ", params$state,
    " Area (", params$base_year, " dollars)"
  )
)
ft_overall
```


# Export Data

```{r}
#| label: export

# Create output directory
base::dir.create("out", showWarnings = FALSE, recursive = TRUE)

# File base name
file_base <- base::paste0(
  "out/pums_gov_earnings_",
  base::tolower(base::gsub(" ", "_", params$city)), "_",
  params$state, "_",
  base::min(params$years), "_", base::max(params$years)
)

# Save results as RDS
base::saveRDS(gov_results, base::paste0(file_base, "_by_level.rds"))
base::saveRDS(overall_results, base::paste0(file_base, "_overall.rds"))

# Save as CSV
readr::write_csv(gov_results, base::paste0(file_base, "_by_level.csv"))
readr::write_csv(overall_results, base::paste0(file_base, "_overall.csv"))

# Save as Excel
writexl::write_xlsx(
  base::list(
    by_government_level = gov_results,
    all_government = overall_results,
    inflation_rate = inflation_rate,
    cpi_factors = cpi_tbl
  ),
  base::paste0(file_base, ".xlsx")
)
```

Data exported to `out/` directory:
- **By level**: `r base::paste0(file_base, "_by_level.rds")` / `.csv`
- **Overall**: `r base::paste0(file_base, "_overall.rds")` / `.csv`
- **Excel**: `r base::paste0(file_base, ".xlsx")` (4 sheets)


# Using This Template

To analyze a different city, change these values in the `params` code chunk:

```r
params <- base::list(
  city       = "Austin",
  state      = "TX",
  years      = c(2019, 2020, 2021, 2023),  # 2022 excluded due to PUMA issues
  min_age    = 20L,
  survey     = "acs5",
  base_year  = 2023,
  cache_dir  = "cache/pums_gov"
)
```

**First run** for a new city will download ~200MB per year from Census. **Subsequent runs** use cached data and complete in seconds.

To force fresh data download, clear the cache:

```r
unlink("cache/pums_gov", recursive = TRUE)
```


# Notes

**Class of Worker (COW) Variable:**

| Code | Description |
|------|-------------|
| 1 | Private for-profit employee |
| 2 | Private not-for-profit employee |
| 3 | Local government employee |
| 4 | State government employee |
| 5 | Federal government employee |
| 6 | Self-employed (incorporated) |
| 7 | Self-employed (not incorporated) |
| 8 | Working without pay in family business |
| 9 | Unemployed, never worked |

**Definitions:**

- **Mean Earnings**: Average of wages + self-employment income among employees
- **Median Earnings**: Middle value of earnings
- **Employees**: Weighted count from PUMS person weights

**Caveats:**

- Data represents the PUMA area, not just the city
- Government employees may live in one area but work elsewhere
- COW reflects current or most recent job in past 5 years
- Small sample sizes for some government levels may result in large standard errors
- Year 2022 is excluded due to PUMA boundary definition inconsistencies in tidycensus
